<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>I2c_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__i2c__api.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2c_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga73250bf554c0d1ebb7e55c45a258f38e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga73250bf554c0d1ebb7e55c45a258f38e">I2CMasterInitExpClk</a> (uint32_t ui32Base, uint32_t ui32I2CClk, bool bFast)</td></tr>
<tr class="separator:ga73250bf554c0d1ebb7e55c45a258f38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843d1157f288f31316c25c7df34d12f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga843d1157f288f31316c25c7df34d12f5">I2CSlaveInit</a> (uint32_t ui32Base, uint8_t ui8SlaveAddr)</td></tr>
<tr class="separator:ga843d1157f288f31316c25c7df34d12f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae525b18201bf108fbf20ec3be4cef092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gae525b18201bf108fbf20ec3be4cef092">I2CSlaveAddressSet</a> (uint32_t ui32Base, uint8_t ui8AddrNum, uint8_t ui8SlaveAddr)</td></tr>
<tr class="separator:gae525b18201bf108fbf20ec3be4cef092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7effd5a21f10dd5398bc74275de5e29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga7effd5a21f10dd5398bc74275de5e29b">I2CMasterEnable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga7effd5a21f10dd5398bc74275de5e29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d6fcf93130b74896a2857884582cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga76d6fcf93130b74896a2857884582cca">I2CSlaveEnable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga76d6fcf93130b74896a2857884582cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799a7da56fe33a827e66120488b1bd98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga799a7da56fe33a827e66120488b1bd98">I2CMasterDisable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga799a7da56fe33a827e66120488b1bd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c7599fd4711c6c0a58199b2e6f7193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaf8c7599fd4711c6c0a58199b2e6f7193">I2CSlaveDisable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaf8c7599fd4711c6c0a58199b2e6f7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d2b0e0e18ba83c8307f8e1eeef05c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga0d2b0e0e18ba83c8307f8e1eeef05c0a">I2CIntRegister</a> (uint32_t ui32Base, void(*pfnHandler)(void))</td></tr>
<tr class="separator:ga0d2b0e0e18ba83c8307f8e1eeef05c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09693552b5d757f37fe7ab54f191619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaf09693552b5d757f37fe7ab54f191619">I2CIntUnregister</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaf09693552b5d757f37fe7ab54f191619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c52db760002449da1f7ec274a43917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaa5c52db760002449da1f7ec274a43917">I2CMasterIntEnable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaa5c52db760002449da1f7ec274a43917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a19948f12f680cb594f55847e247758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga5a19948f12f680cb594f55847e247758">I2CMasterIntEnableEx</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga5a19948f12f680cb594f55847e247758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa4ef36c2dec6429e6c1a3fa51640f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga8fa4ef36c2dec6429e6c1a3fa51640f5">I2CSlaveIntEnable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga8fa4ef36c2dec6429e6c1a3fa51640f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5987054c8be4c5ecc23ba66228285a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga7f5987054c8be4c5ecc23ba66228285a">I2CSlaveIntEnableEx</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga7f5987054c8be4c5ecc23ba66228285a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d53c3aa4819243d8bd9a9ed44b39c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga09d53c3aa4819243d8bd9a9ed44b39c3">I2CMasterIntDisable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga09d53c3aa4819243d8bd9a9ed44b39c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ce97839e6ce8a602870558ac14c714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga93ce97839e6ce8a602870558ac14c714">I2CMasterIntDisableEx</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga93ce97839e6ce8a602870558ac14c714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb3fd03a5e1ad968bf062d5946a33f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gadfb3fd03a5e1ad968bf062d5946a33f3">I2CSlaveIntDisable</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gadfb3fd03a5e1ad968bf062d5946a33f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de6e8a6ee17e1ed5c7406066544bf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga8de6e8a6ee17e1ed5c7406066544bf0e">I2CSlaveIntDisableEx</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga8de6e8a6ee17e1ed5c7406066544bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97d17a331d54ec61721ab37909b81ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaa97d17a331d54ec61721ab37909b81ca">I2CMasterIntStatus</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr class="separator:gaa97d17a331d54ec61721ab37909b81ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6fd5834fbe9a89e27398af7fe9d571"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gafe6fd5834fbe9a89e27398af7fe9d571">I2CMasterIntStatusEx</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr class="separator:gafe6fd5834fbe9a89e27398af7fe9d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c46ee46d1c14467a289024b80eb1b68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga9c46ee46d1c14467a289024b80eb1b68">I2CSlaveIntStatus</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr class="separator:ga9c46ee46d1c14467a289024b80eb1b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdbd0bd1a6597450d0f153633e5bfe5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gabbdbd0bd1a6597450d0f153633e5bfe5">I2CSlaveIntStatusEx</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr class="separator:gabbdbd0bd1a6597450d0f153633e5bfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50c838fb4a1b1eb0a343b5e5e0977d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gae50c838fb4a1b1eb0a343b5e5e0977d7">I2CMasterIntClear</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gae50c838fb4a1b1eb0a343b5e5e0977d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de86eea4a07416ab3cc09d6b85f90ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga0de86eea4a07416ab3cc09d6b85f90ee">I2CMasterIntClearEx</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga0de86eea4a07416ab3cc09d6b85f90ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07e0bb27ba7beadac1713ac7187ba9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gad07e0bb27ba7beadac1713ac7187ba9c">I2CSlaveIntClear</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gad07e0bb27ba7beadac1713ac7187ba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9988111d64e13ad076a8e09841fb830e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga9988111d64e13ad076a8e09841fb830e">I2CSlaveIntClearEx</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr class="separator:ga9988111d64e13ad076a8e09841fb830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c9585a226d1ab8e7fe77728b0a9ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga71c9585a226d1ab8e7fe77728b0a9ca9">I2CMasterSlaveAddrSet</a> (uint32_t ui32Base, uint8_t ui8SlaveAddr, bool bReceive)</td></tr>
<tr class="separator:ga71c9585a226d1ab8e7fe77728b0a9ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020f1291ca0cfe718c1f893ca7d1d961"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga020f1291ca0cfe718c1f893ca7d1d961">I2CMasterLineStateGet</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga020f1291ca0cfe718c1f893ca7d1d961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487483843df9f0e057d2235218d3b183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga487483843df9f0e057d2235218d3b183">I2CMasterBusy</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga487483843df9f0e057d2235218d3b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba2163975eac91438b017ab22e61020"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga7ba2163975eac91438b017ab22e61020">I2CMasterBusBusy</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga7ba2163975eac91438b017ab22e61020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec6254eefae0f4776eba37ce365a7a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga2ec6254eefae0f4776eba37ce365a7a7">I2CMasterControl</a> (uint32_t ui32Base, uint32_t ui32Cmd)</td></tr>
<tr class="separator:ga2ec6254eefae0f4776eba37ce365a7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9555a0e3bb6efe55246b5ca249de6f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaf9555a0e3bb6efe55246b5ca249de6f1">I2CMasterErr</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaf9555a0e3bb6efe55246b5ca249de6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b04622258dd620d1ee96a5a03eec3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga2b04622258dd620d1ee96a5a03eec3c3">I2CMasterDataPut</a> (uint32_t ui32Base, uint8_t ui8Data)</td></tr>
<tr class="separator:ga2b04622258dd620d1ee96a5a03eec3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630e3dbdc9f3f93b1173ff53cb912c7e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga630e3dbdc9f3f93b1173ff53cb912c7e">I2CMasterDataGet</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga630e3dbdc9f3f93b1173ff53cb912c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d7c959996d278cee5869703c11a088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gad2d7c959996d278cee5869703c11a088">I2CMasterTimeoutSet</a> (uint32_t ui32Base, uint32_t ui32Value)</td></tr>
<tr class="separator:gad2d7c959996d278cee5869703c11a088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c70a55d6624915579c2fc64e38cc3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga6c70a55d6624915579c2fc64e38cc3a1">I2CSlaveACKOverride</a> (uint32_t ui32Base, bool bEnable)</td></tr>
<tr class="separator:ga6c70a55d6624915579c2fc64e38cc3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56951e3afb08694f4f9deb45e73112a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga56951e3afb08694f4f9deb45e73112a3">I2CSlaveACKValueSet</a> (uint32_t ui32Base, bool bACK)</td></tr>
<tr class="separator:ga56951e3afb08694f4f9deb45e73112a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e521681152d19d005a5adaafc4dc97"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaa4e521681152d19d005a5adaafc4dc97">I2CSlaveStatus</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaa4e521681152d19d005a5adaafc4dc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00372537c4587a1d4fed0373997af1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#gaf00372537c4587a1d4fed0373997af1b">I2CSlaveDataPut</a> (uint32_t ui32Base, uint8_t ui8Data)</td></tr>
<tr class="separator:gaf00372537c4587a1d4fed0373997af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b1906ecd21737e3f4a8052ce4198c6b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__api.html#ga7b1906ecd21737e3f4a8052ce4198c6b">I2CSlaveDataGet</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga7b1906ecd21737e3f4a8052ce4198c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0d2b0e0e18ba83c8307f8e1eeef05c0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CIntRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the I2C module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the I2C interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the handler to be called when an I2C interrupt occurs. This function enables the global interrupt in the interrupt controller; specific I2C interrupts must be enabled via <a class="el" href="group__i2c__api.html#gaa5c52db760002449da1f7ec274a43917">I2CMasterIntEnable()</a> and <a class="el" href="group__i2c__api.html#ga8fa4ef36c2dec6429e6c1a3fa51640f5">I2CSlaveIntEnable()</a>. If necessary, it is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__i2c__api.html#gae50c838fb4a1b1eb0a343b5e5e0977d7">I2CMasterIntClear()</a> and <a class="el" href="group__i2c__api.html#gad07e0bb27ba7beadac1713ac7187ba9c">I2CSlaveIntClear()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf09693552b5d757f37fe7ab54f191619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CIntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters an interrupt handler for the I2C module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the handler to be called when an I2C interrupt occurs. This function also masks off the interrupt in the interrupt r controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ba2163975eac91438b017ab22e61020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CMasterBusBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether or not the I2C bus is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not the I2C bus is busy. This function can be used in a multi-master environment to determine if another master is currently using the bus.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the I2C bus is busy; otherwise, returns <b>false</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga487483843df9f0e057d2235218d3b183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CMasterBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether or not the I2C Master is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not the I2C Master is busy transmitting or receiving data.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the I2C Master is busy; otherwise, returns <b>false</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ec6254eefae0f4776eba37ce365a7a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the state of the I2C Master module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui32Cmd</td><td>command to be issued to the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to control the state of the Master module send and receive operations. The <em>ui8Cmd</em> parameter can be one of the following values:</p>
<ul>
<li><b>I2C_MASTER_CMD_SINGLE_SEND</b> </li>
<li><b>I2C_MASTER_CMD_SINGLE_RECEIVE</b> </li>
<li><b>I2C_MASTER_CMD_BURST_SEND_START</b> </li>
<li><b>I2C_MASTER_CMD_BURST_SEND_CONT</b> </li>
<li><b>I2C_MASTER_CMD_BURST_SEND_FINISH</b> </li>
<li><b>I2C_MASTER_CMD_BURST_SEND_ERROR_STOP</b> </li>
<li><b>I2C_MASTER_CMD_BURST_RECEIVE_START</b> </li>
<li><b>I2C_MASTER_CMD_BURST_RECEIVE_CONT</b> </li>
<li><b>I2C_MASTER_CMD_BURST_RECEIVE_FINISH</b> </li>
<li><b>I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP</b> </li>
<li><b>I2C_MASTER_CMD_QUICK_COMMAND</b> </li>
<li><b>I2C_MASTER_CMD_HS_MASTER_CODE_SEND</b> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga630e3dbdc9f3f93b1173ff53cb912c7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterDataGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives a byte that has been sent to the I2C Master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a byte of data from the I2C Master Data Register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C Master, cast as an uint32_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b04622258dd620d1ee96a5a03eec3c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterDataPut </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmits a byte from the I2C Master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui8Data</td><td>data to be transmitted from the I2C Master.</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the supplied data into I2C Master Data Register.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga799a7da56fe33a827e66120488b1bd98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the I2C master block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the I2C master block.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7effd5a21f10dd5398bc74275de5e29b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the I2C Master block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables operation of the I2C Master block.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9555a0e3bb6efe55246b5ca249de6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterErr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the error status of the I2C Master module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to obtain the error status of the Master module send and receive operations.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the error status, as one of <b>I2C_MASTER_ERR_NONE</b>, <b>I2C_MASTER_ERR_ADDR_ACK</b>, <b>I2C_MASTER_ERR_DATA_ACK</b>, or <b>I2C_MASTER_ERR_ARB_LOST</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73250bf554c0d1ebb7e55c45a258f38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterInitExpClk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32I2CClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the I2C Master block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui32I2CClk</td><td>is the rate of the clock supplied to the I2C module. </td></tr>
    <tr><td class="paramname">bFast</td><td>set up for fast data transfers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes operation of the I2C Master block by configuring the bus speed for the master and enabling the I2C Master block.</p>
<p>If the parameter <em>bFast</em> is <b>true</b>, then the master block is set up to transfer data at 400 Kbps; otherwise, it is set up to transfer data at 100 Kbps. If Fast Mode Plus (1 Mbps) is desired, software should manually write the I2CMTPR after calling this function. For High Speed (3.4 Mbps) mode, a specific command is used to switch to the faster clocks after the initial communication with the slave is done at either 100 Kbps or 400 Kbps.</p>
<p>The peripheral clock is the same as the processor clock. This value is returned by <a class="el" href="group__sysctl__api.html#ga97d96b02b249a16354577bde88ece728">SysCtlClockGet()</a>, or it can be explicitly hard coded if it is constant and known (to save the code/execution overhead of a call to <a class="el" href="group__sysctl__api.html#ga97d96b02b249a16354577bde88ece728">SysCtlClockGet()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae50c838fb4a1b1eb0a343b5e5e0977d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears I2C Master interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>The I2C Master interrupt source is cleared, so that it no longer asserts. This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0de86eea4a07416ab3cc09d6b85f90ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntClearEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears I2C Master interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified I2C Master interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<p>The <em>ui32IntFlags</em> parameter has the same definition as the <em>ui32IntFlags</em> parameter to <a class="el" href="group__i2c__api.html#ga5a19948f12f680cb594f55847e247758">I2CMasterIntEnableEx()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09d53c3aa4819243d8bd9a9ed44b39c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the I2C Master interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the I2C Master interrupt source.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93ce97839e6ce8a602870558ac14c714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntDisableEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual I2C Master interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated I2C Master interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The <em>ui32IntFlags</em> parameter has the same definition as the <em>ui32IntFlags</em> parameter to <a class="el" href="group__i2c__api.html#ga5a19948f12f680cb594f55847e247758">I2CMasterIntEnableEx()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5c52db760002449da1f7ec274a43917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the I2C Master interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the I2C Master interrupt source.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a19948f12f680cb594f55847e247758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterIntEnableEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual I2C Master interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated I2C Master interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The <em>ui32IntFlags</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>I2C_MASTER_INT_TIMEOUT</b> - Clock Timeout interrupt</li>
<li><b>I2C_MASTER_INT_DATA</b> - Data interrupt</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support all of the listed interrupt sources. Please consult the device data sheet to determine if these features are supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa97d17a331d54ec61721ab37909b81ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CMasterIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current I2C Master interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is requested and true if the masked interrupt status is requested.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the I2C Master module. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, returned as <b>true</b> if active or <b>false</b> if not active. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe6fd5834fbe9a89e27398af7fe9d571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterIntStatusEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current I2C Master interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is requested and true if the masked interrupt status is requested.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the I2C Master module. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status, enumerated as a bit field of values described in <a class="el" href="group__i2c__api.html#ga5a19948f12f680cb594f55847e247758">I2CMasterIntEnableEx()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga020f1291ca0cfe718c1f893ca7d1d961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterLineStateGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the state of the SDA and SCL pins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the state of the I2C bus by providing the real time values of the SDA and SCL pins.</p>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support this function. Please consult the device data sheet to determine if this feature is supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the state of the bus with SDA in bit position 1 and SCL in bit position 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71c9585a226d1ab8e7fe77728b0a9ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterSlaveAddrSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8SlaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReceive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the address that the I2C Master places on the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui8SlaveAddr</td><td>7-bit slave address </td></tr>
    <tr><td class="paramname">bReceive</td><td>flag indicating the type of communication with the slave</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the address that the I2C Master places on the bus when initiating a transaction. When the <em>bReceive</em> parameter is set to <b>true</b>, the address indicates that the I2C Master is initiating a read from the slave; otherwise the address indicates that the I2C Master is initiating a write to the slave.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2d7c959996d278cee5869703c11a088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterTimeoutSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Master clock timeout value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Master module. </td></tr>
    <tr><td class="paramname">ui32Value</td><td>is the number of I2C clocks before the timeout is asserted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and configures the clock low timeout feature in the I2C peripheral. This feature is implemented as a 12-bit counter, with the upper 8-bits being programmable. For example, to program a timeout of 20ms with a 100kHz SCL frequency, <em>ui32Value</em> would be 0x7d.</p>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support this function. Please consult the device data sheet to determine if this feature is supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c70a55d6624915579c2fc64e38cc3a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveACKOverride </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures ACK override behavior of the I2C Slave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">bEnable</td><td>enables or disables ACK override.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables or disables ACK override, allowing the user application to drive the value on SDA during the ACK cycle.</p>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support this function. Please consult the device data sheet to determine if this feature is supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56951e3afb08694f4f9deb45e73112a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveACKValueSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bACK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the ACK value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">bACK</td><td>chooses whether to ACK (true) or NACK (false) the transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function puts the desired ACK value on SDA during the ACK cycle. The value written is only valid when ACK override is enabled using <a class="el" href="group__i2c__api.html#ga6c70a55d6624915579c2fc64e38cc3a1">I2CSlaveACKOverride()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae525b18201bf108fbf20ec3be4cef092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveAddressSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8AddrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8SlaveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the I2C slave address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">ui8AddrNum</td><td>determines which slave address is set. </td></tr>
    <tr><td class="paramname">ui8SlaveAddr</td><td>is the 7-bit slave address</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the specified slave address. The <em>ui32AddrNum</em> field dictates which slave address is configured. For example, a value of 0 configures the primary address and a value of 1 configures the secondary.</p>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support a secondary address. Please consult the device data sheet to determine if this feature is supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b1906ecd21737e3f4a8052ce4198c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveDataGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives a byte that has been sent to the I2C Slave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a byte of data from the I2C Slave Data Register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C Slave, cast as an uint32_t. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf00372537c4587a1d4fed0373997af1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveDataPut </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmits a byte from the I2C Slave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">ui8Data</td><td>is the data to be transmitted from the I2C Slave</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the supplied data into I2C Slave Data Register.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8c7599fd4711c6c0a58199b2e6f7193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the I2C slave block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the I2C slave block.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76d6fcf93130b74896a2857884582cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the I2C Slave block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>This fucntion enables operation of the I2C Slave block.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga843d1157f288f31316c25c7df34d12f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8SlaveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the I2C Slave block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">ui8SlaveAddr</td><td>7-bit slave address</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes operation of the I2C Slave block by configuring the slave address and enabling the I2C Slave block.</p>
<p>The parameter <em>ui8SlaveAddr</em> is the value that is compared against the slave address sent by an I2C master.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad07e0bb27ba7beadac1713ac7187ba9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears I2C Slave interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>The I2C Slave interrupt source is cleared, so that it no longer asserts. This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9988111d64e13ad076a8e09841fb830e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntClearEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears I2C Slave interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified I2C Slave interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<p>The <em>ui32IntFlags</em> parameter has the same definition as the <em>ui32IntFlags</em> parameter to <a class="el" href="group__i2c__api.html#ga7f5987054c8be4c5ecc23ba66228285a">I2CSlaveIntEnableEx()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gadfb3fd03a5e1ad968bf062d5946a33f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the I2C Slave interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the I2C Slave interrupt source.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8de6e8a6ee17e1ed5c7406066544bf0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntDisableEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual I2C Slave interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated I2C Slave interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The <em>ui32IntFlags</em> parameter has the same definition as the <em>ui32IntFlags</em> parameter to <a class="el" href="group__i2c__api.html#ga7f5987054c8be4c5ecc23ba66228285a">I2CSlaveIntEnableEx()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fa4ef36c2dec6429e6c1a3fa51640f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the I2C Slave interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the I2C Slave interrupt source.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f5987054c8be4c5ecc23ba66228285a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSlaveIntEnableEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual I2C Slave interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated I2C Slave interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The <em>ui32IntFlags</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>I2C_SLAVE_INT_STOP</b> - Stop condition detected interrupt</li>
<li><b>I2C_SLAVE_INT_START</b> - Start condition detected interrupt</li>
<li><b>I2C_SLAVE_INT_DATA</b> - Data interrupt</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support the all of the listed interrupts. Please consult the device data sheet to determine if these features are supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c46ee46d1c14467a289024b80eb1b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CSlaveIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current I2C Slave interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is requested and true if the masked interrupt status is requested.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the I2C Slave module. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, returned as <b>true</b> if active or <b>false</b> if not active. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbdbd0bd1a6597450d0f153633e5bfe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveIntStatusEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current I2C Slave interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is requested and true if the masked interrupt status is requested.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the I2C Slave module. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status, enumerated as a bit field of values described in <a class="el" href="group__i2c__api.html#ga7f5987054c8be4c5ecc23ba66228285a">I2CSlaveIntEnableEx()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4e521681152d19d005a5adaafc4dc97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CSlaveStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the I2C Slave module status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the I2C Slave module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the action requested from a master, if any. Possible values are:</p>
<ul>
<li><b>I2C_SLAVE_ACT_NONE</b> </li>
<li><b>I2C_SLAVE_ACT_RREQ</b> </li>
<li><b>I2C_SLAVE_ACT_TREQ</b> </li>
<li><b>I2C_SLAVE_ACT_RREQ_FBR</b> </li>
<li><b>I2C_SLAVE_ACT_OWN2SEL</b> </li>
<li><b>I2C_SLAVE_ACT_QCMD</b> </li>
<li><b>I2C_SLAVE_ACT_QCMD_DATA</b> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Not all Tiva devices support the second I2C slave's own address or the quick command function. Please consult the device data sheet to determine if these features are supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>I2C_SLAVE_ACT_NONE</b> to indicate that no action has been requested of the I2C Slave module, <b>I2C_SLAVE_ACT_RREQ</b> to indicate that an I2C master has sent data to the I2C Slave module, <b>I2C_SLAVE_ACT_TREQ</b> to indicate that an I2C master has requested that the I2C Slave module send data, <b>I2C_SLAVE_ACT_RREQ_FBR</b> to indicate that an I2C master has sent data to the I2C slave and the first byte following the slave's own address has been received, <b>I2C_SLAVE_ACT_OWN2SEL</b> to indicate that the second I2C slave address was matched, <b>I2C_SLAVE_ACT_QCMD</b> to indicate that a quick command was received, and <b>I2C_SLAVE_ACT_QCMD_DATA</b> to indicate that the data bit was set when the quick command was received. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Mar 18 2014 02:26:34 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
